"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5385],{6127:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"topics/topics","title":"ROS 2 Topics","description":"Introduction","source":"@site/docs/03_topics/02_topics.md","sourceDirName":"03_topics","slug":"/topics/topics","permalink":"/ROS2-Beginners/docs/topics/topics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/03_topics/02_topics.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Topics","permalink":"/ROS2-Beginners/docs/topics/intro"},"next":{"title":"publisher","permalink":"/ROS2-Beginners/docs/topics/publisher"}}');var r=s(4848),t=s(8453);const c={},a="ROS 2 Topics",o={},l=[{value:"Introduction",id:"introduction",level:2},{value:"ROS 2 Topics: Overview",id:"ros-2-topics-overview",level:2},{value:"Key Characteristics of ROS 2 Topics",id:"key-characteristics-of-ros-2-topics",level:3},{value:"Analogy: Radio Transmitter and Receiver (Refined)",id:"analogy-radio-transmitter-and-receiver-refined",level:3},{value:"Multiple Publishers and Subscribers",id:"multiple-publishers-and-subscribers",level:3},{value:"Nodes and Topics: Practical Usage",id:"nodes-and-topics-practical-usage",level:2},{value:"Creating and Using Topics in ROS 2",id:"creating-and-using-topics-in-ros-2",level:3},{value:"Example: Creating a Publisher",id:"example-creating-a-publisher",level:3},{value:"In Python (using <code>rclpy</code>):",id:"in-python-using-rclpy",level:4},{value:"In C++ (using <code>rclcpp</code>):",id:"in-c-using-rclcpp",level:4},{value:"Example: Creating a Subscriber",id:"example-creating-a-subscriber",level:3},{value:"In Python (using <code>rclpy</code>):",id:"in-python-using-rclpy-1",level:4},{value:"In C++ (using <code>rclcpp</code>):",id:"in-c-using-rclcpp-1",level:4},{value:"Explanation of Code",id:"explanation-of-code",level:3},{value:"Naming Conventions and Best Practices",id:"naming-conventions-and-best-practices",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"ros-2-topics",children:"ROS 2 Topics"})}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["In the Robot Operating System 2 (ROS 2), ",(0,r.jsx)(n.em,{children:"topics"})," are fundamental communication channels that enable nodes (the basic executable units in ROS 2) to exchange messages in a decoupled and scalable manner. This architecture is essential for building complex robotic systems, where various components need to interact seamlessly without being tightly coupled to one another. Understanding ROS 2 topics is crucial for developing modular and maintainable robotic software."]}),"\n",(0,r.jsx)(n.p,{children:"This tutorial will provide a detailed and technically rigorous overview of ROS 2 topics, including their key characteristics, usage, and practical implementation. We will also correct and refine any analogies and explanations to ensure they meet the high standards expected in the field of robotics."}),"\n",(0,r.jsx)(n.h2,{id:"ros-2-topics-overview",children:"ROS 2 Topics: Overview"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"topic"})," in ROS 2 acts as a named communication bus over which nodes send and receive messages. Topics enable unidirectional communication: one or more nodes (publishers) can publish messages to a topic, and one or more nodes (subscribers) can receive these messages. This mechanism ensures that nodes remain loosely coupled, meaning that they can operate independently without direct knowledge of each other."]}),"\n",(0,r.jsx)(n.h3,{id:"key-characteristics-of-ros-2-topics",children:"Key Characteristics of ROS 2 Topics"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Unidirectional Communication"}),": Topics facilitate unidirectional data flow from publishers to subscribers. There is no direct feedback loop from subscribers to publishers, although subscribers can publish their own messages to another topic if needed."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Anonymity"}),": Publishers and subscribers do not need to be aware of each other. A publisher does not know how many subscribers are listening to the topic, and similarly, a subscriber does not know how many publishers are sending data. This anonymity enhances the flexibility and scalability of the system."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Message Type Consistency"}),": All nodes that publish or subscribe to a particular topic must use the same message type. This ensures that the data being transmitted is correctly interpreted by all subscribers, preventing communication errors."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"analogy-radio-transmitter-and-receiver-refined",children:"Analogy: Radio Transmitter and Receiver (Refined)"}),"\n",(0,r.jsx)(n.p,{children:"A more accurate analogy can be made by comparing ROS 2 topics to a radio broadcast system, where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Radio Transmitter (Publisher)"}),": A radio transmitter sends audio signals (music, news, etc.) on a specific frequency. In ROS 2, this corresponds to a publisher node that sends data on a specific topic."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Radio Receiver (Subscriber)"}),": A radio receiver, tuned to a particular frequency, receives the broadcast from the transmitter. In ROS 2, this represents a subscriber node that listens to a specific topic to receive data."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In this analogy:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Publisher"}),": The node that publishes data to a topic."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Subscriber"}),": The node that subscribes to a topic to receive data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Topic"}),": The named channel (analogous to a radio frequency) over which data is transmitted."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"multiple-publishers-and-subscribers",children:"Multiple Publishers and Subscribers"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 topics allow for multiple publishers and subscribers on the same topic, supporting complex communication patterns:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Multiple Publishers"}),": Multiple nodes can publish messages to the same topic. This can be useful in scenarios where data from different sources needs to be aggregated or processed in parallel. ROS 2 manages potential conflicts (analogous to interference in radio systems) by ensuring that messages are delivered reliably according to Quality of Service (QoS) settings."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Multiple Subscribers"}),": Multiple nodes can subscribe to the same topic, each independently receiving and processing the data. This allows for distributed processing, where different parts of the system can react to the same data stream in different ways."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"nodes-and-topics-practical-usage",children:"Nodes and Topics: Practical Usage"}),"\n",(0,r.jsxs)(n.p,{children:["A ROS 2 node can be designed to have multiple publishers and subscribers, allowing it to interact with various parts of the system simultaneously. For example, a robot\u2019s navigation node might subscribe to sensor data from multiple topics (e.g., ",(0,r.jsx)(n.code,{children:"camera"}),", ",(0,r.jsx)(n.code,{children:"lidar"}),") and publish commands to another topic (e.g., ",(0,r.jsx)(n.code,{children:"cmd_vel"})," for velocity commands)."]}),"\n",(0,r.jsx)(n.h3,{id:"creating-and-using-topics-in-ros-2",children:"Creating and Using Topics in ROS 2"}),"\n",(0,r.jsx)(n.p,{children:"Let's explore how to create a simple publisher and subscriber in ROS 2, using both Python and C++."}),"\n",(0,r.jsx)(n.h3,{id:"example-creating-a-publisher",children:"Example: Creating a Publisher"}),"\n",(0,r.jsxs)(n.h4,{id:"in-python-using-rclpy",children:["In Python (using ",(0,r.jsx)(n.code,{children:"rclpy"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass Talker(Node):\n    def __init__(self):\n        super().__init__('talker')\n        self.publisher_ = self.create_publisher(String, 'chatter', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello, world!'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = Talker()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"in-c-using-rclcpp",children:["In C++ (using ",(0,r.jsx)(n.code,{children:"rclcpp"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include <rclcpp/rclcpp.hpp>\n#include <std_msgs/msg/string.hpp>\n\nclass Talker : public rclcpp::Node\n{\npublic:\n    Talker() : Node("talker")\n    {\n        publisher_ = this->create_publisher<std_msgs::msg::String>("chatter", 10);\n        timer_ = this->create_wall_timer(\n            500ms, std::bind(&Talker::timer_callback, this));\n    }\n\nprivate:\n    void timer_callback()\n    {\n        auto message = std_msgs::msg::String();\n        message.data = "Hello, world!";\n        RCLCPP_INFO(this->get_logger(), "Publishing: \'%s\'", message.data.c_str());\n        publisher_->publish(message);\n    }\n    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;\n    rclcpp::TimerBase::SharedPtr timer_;\n};\n\nint main(int argc, char *argv[])\n{\n    rclcpp::init(argc, argv);\n    rclcpp::spin(std::make_shared<Talker>());\n    rclcpp::shutdown();\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"example-creating-a-subscriber",children:"Example: Creating a Subscriber"}),"\n",(0,r.jsxs)(n.h4,{id:"in-python-using-rclpy-1",children:["In Python (using ",(0,r.jsx)(n.code,{children:"rclpy"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass Listener(Node):\n    def __init__(self):\n        super().__init__('listener')\n        self.subscription = self.create_subscription(\n            String,\n            'chatter',\n            self.listener_callback,\n            10)\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = Listener()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"in-c-using-rclcpp-1",children:["In C++ (using ",(0,r.jsx)(n.code,{children:"rclcpp"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include <rclcpp/rclcpp.hpp>\n#include <std_msgs/msg/string.hpp>\n\nclass Listener : public rclcpp::Node\n{\npublic:\n    Listener() : Node("listener")\n    {\n        subscription_ = this->create_subscription<std_msgs::msg::String>(\n            "chatter", 10, std::bind(&Listener::topic_callback, this, std::placeholders::_1));\n    }\n\nprivate:\n    void topic_callback(const std_msgs::msg::String::SharedPtr msg) const\n    {\n        RCLCPP_INFO(this->get_logger(), "I heard: \'%s\'", msg->data.c_str());\n    }\n    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;\n};\n\nint main(int argc, char *argv[])\n{\n    rclcpp::init(argc, argv);\n    rclcpp::spin(std::make_shared<Listener>());\n    rclcpp::shutdown();\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"explanation-of-code",children:"Explanation of Code"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Publisher"}),": The ",(0,r.jsx)(n.code,{children:"Talker"})," node periodically publishes a ",(0,r.jsx)(n.code,{children:"String"}),' message with the content "Hello, world!" on the ',(0,r.jsx)(n.code,{children:"chatter"})," topic."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Subscriber"}),": The ",(0,r.jsx)(n.code,{children:"Listener"})," node subscribes to the ",(0,r.jsx)(n.code,{children:"chatter"})," topic and prints out any messages it receives."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These simple examples illustrate how ROS 2 topics can be used to enable communication between different nodes."}),"\n",(0,r.jsx)(n.h2,{id:"naming-conventions-and-best-practices",children:"Naming Conventions and Best Practices"}),"\n",(0,r.jsx)(n.p,{children:"Adhering to best practices in naming and structuring topics is essential for maintaining a well-organized and scalable ROS 2 system."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Topic Naming"}),": Topic names should start with a letter and can include letters, numbers, underscores (",(0,r.jsx)(n.code,{children:"_"}),"), tildes (",(0,r.jsx)(n.code,{children:"~"}),"), and slashes (",(0,r.jsx)(n.code,{children:"/"}),"). It's good practice to use descriptive names that clearly indicate the topic's purpose (e.g., ",(0,r.jsx)(n.code,{children:"camera/image_raw"})," for raw image data from a camera)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Message Types"}),": Ensure that all nodes interacting through a topic agree on the message type. Using custom message types when necessary can help encapsulate complex data structures."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decoupling"}),": Design your nodes and topics to be as decoupled as possible. This makes it easier to test individual components, replace or upgrade them without affecting the rest of the system, and scale the system to handle additional functionalities."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 topics are a powerful mechanism for inter-node communication in robotic systems, enabling the development of flexible, modular, and scalable software. By understanding and correctly implementing topics, publishers, and subscribers, developers can create robust robotic applications that efficiently handle data exchange between various system components. This tutorial has provided a comprehensive overview of ROS 2 topics, from basic concepts to practical implementation, ensuring that you are well-equipped to utilize this fundamental feature in your own ROS 2 projects."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function c(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);